# Implementation Plan: Qobuz Format Fallback

**Branch**: `003-qobuz-format-fallback` | **Date**: 2026-02-14 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/003-qobuz-format-fallback/spec.md`

## Summary

When requesting a Qobuz track download URL with `format_id=5` (MP3 320) fails, automatically retry with `format_id=6` (CD Quality / FLAC 16-bit 44.1kHz). Downloaded FLAC files use `.flac` extension. The incremental sync check must recognize both `.mp3` and `.flac` as "already synced" for the same track position.

## Technical Context

**Language/Version**: Rust (edition 2024, rust-version 1.93)
**Primary Dependencies**: reqwest, serde, clap, indicatif, tokio, futures
**Storage**: Local filesystem
**Testing**: cargo test (unit tests in tests/)
**Target Platform**: macOS / Linux CLI
**Project Type**: Single Rust binary
**Performance Goals**: No additional HTTP requests when MP3 succeeds (zero overhead for happy path)
**Constraints**: Format fallback adds at most 1 extra HTTP request per track that fails MP3
**Scale/Scope**: ~4 files modified, ~50-80 lines of new/changed code

## Constitution Check

Constitution is unconfigured (template placeholders). No gates to evaluate.

## Project Structure

### Documentation (this feature)

```text
specs/003-qobuz-format-fallback/
├── plan.md              # This file
├── research.md          # Qobuz format ID research
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (files affected)

```text
src/
├── download.rs          # Primary change: fallback logic in download_one()
├── sync.rs              # Change: scan_existing checks both .mp3 and .flac
├── models.rs            # Change: DownloadTask/SyncResult may carry format info
├── main.rs              # Change: summary output includes fallback count
└── client.rs            # No change (already parameterized by format_id)

tests/
└── (existing tests updated as needed)
```

**Structure Decision**: Existing single-binary Rust project. No new files needed — all changes are modifications to existing modules.

## Design Decisions

### 1. Where does fallback logic live?

**Decision**: In `download_one()` in `src/download.rs`.

**Rationale**: `download_one()` already calls `client.get_file_url(track_id, FORMAT_ID_MP3_320)`. The fallback is a simple retry with a different format_id. This keeps the fallback contained in the download layer — the sync planning layer doesn't need to know about formats.

**Approach**: `download_one()` calls `get_file_url` with MP3 320. If that fails (non-retryable error from Qobuz, i.e., 400-level), it retries with CD Quality format_id. If that also fails, the error propagates as before. The function returns information about which format was actually used.

### 2. How does incremental sync handle mixed extensions?

**Decision**: `scan_existing()` in `src/sync.rs` checks for both `.mp3` and `.flac` at each track position.

**Rationale**: `collect_tasks()` builds target paths with `.mp3` extension. But if a previous sync downloaded a track as `.flac` (via fallback), we need to recognize it as already synced. The cheapest approach is to have `scan_existing()` check both extensions for each task's path.

### 3. How does the download function communicate the actual format used?

**Decision**: `download_one()` returns the actual file extension used (which may differ from the planned `.mp3`). The caller tracks fallback count.

**Rationale**: The `DownloadTask` is created with `.mp3` as the planned extension, but the actual download may produce `.flac`. Rather than making the planning layer format-aware, the download layer handles the rename to the correct extension and reports what happened.

### 4. File naming for fallback downloads

**Decision**: When fallback occurs, the target file uses `.flac` extension at the same path position (e.g., `Artist/Album/01 - Track.flac` instead of `Artist/Album/01 - Track.mp3`).

**Rationale**: The file extension should match the actual content. FLAC files named `.mp3` would confuse media players.

### 5. Qobuz format IDs

| Format ID | Format | Notes |
|-----------|--------|-------|
| 5 | MP3 320 kbps | Current default, lossy |
| 6 | FLAC 16-bit/44.1kHz | CD Quality, lossless, fallback |
| 7 | FLAC 24-bit (up to 96kHz) | Hi-res, out of scope |
| 27 | FLAC 24-bit (up to 192kHz) | Hi-res, out of scope |

### 6. Error classification for fallback trigger

**Decision**: Any non-success response from `get_file_url` with MP3 format triggers fallback. Specifically: if the `get_file_url` call returns `Err`, try CD Quality. If that also returns `Err`, report the CD Quality error (more informative since MP3 was already tried).

**Rationale**: Qobuz doesn't document specific error codes for "format unavailable." Treating any failure as a reason to try CD Quality is safe — if the track is genuinely broken (not purchased, region-locked), the CD Quality request will fail too, and we report that.
